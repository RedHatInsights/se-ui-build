{"version":3,"file":"4886.0ccb2280.js","mappings":"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","sources":["webpack://smartevents-ui/./node_modules/ajv/dist/compile/index.js","webpack://smartevents-ui/./node_modules/ajv/dist/compile/ref_error.js","webpack://smartevents-ui/./node_modules/ajv/dist/core.js","webpack://smartevents-ui/./node_modules/ajv/dist/runtime/equal.js","webpack://smartevents-ui/./node_modules/ajv/dist/runtime/ucs2length.js","webpack://smartevents-ui/./node_modules/ajv/dist/runtime/validation_error.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/additionalItems.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/allOf.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/anyOf.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/contains.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/dependencies.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/if.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/index.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/items.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/items2020.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/not.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/oneOf.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/patternProperties.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/prefixItems.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/properties.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/propertyNames.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/applicator/thenElse.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/core/id.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/core/index.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/core/ref.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/discriminator/index.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/discriminator/types.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/draft7.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/format/format.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/format/index.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/metadata.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/validation/const.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/validation/enum.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/validation/index.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/validation/limitItems.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/validation/limitLength.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/validation/limitNumber.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/validation/limitProperties.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/validation/multipleOf.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/validation/pattern.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/validation/required.js","webpack://smartevents-ui/./node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst validation_error_1 = require(\"../runtime/validation_error\");\nconst names_1 = require(\"./names\");\nconst resolve_1 = require(\"./resolve\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nconst URI = require(\"uri-js\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil],\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._) `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = URI.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(p);\n    let baseId = (0, resolve_1.getFullPath)(root.baseId);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst resolve_1 = require(\"./resolve\");\nclass MissingRefError extends Error {\n    constructor(baseId, ref, msg) {\n        super(msg || `can't resolve reference ${ref} from id ${baseId}`);\n        this.missingRef = (0, resolve_1.resolveUrl)(baseId, ref);\n        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(this.missingRef));\n    }\n}\nexports.default = MissingRefError;\n//# sourceMappingURL=ref_error.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    return {\n        strictSchema: (_e = (_d = o.strictSchema) !== null && _d !== void 0 ? _d : s) !== null && _e !== void 0 ? _e : true,\n        strictNumbers: (_g = (_f = o.strictNumbers) !== null && _f !== void 0 ? _f : s) !== null && _g !== void 0 ? _g : true,\n        strictTypes: (_j = (_h = o.strictTypes) !== null && _h !== void 0 ? _h : s) !== null && _j !== void 0 ? _j : \"log\",\n        strictTuples: (_l = (_k = o.strictTuples) !== null && _k !== void 0 ? _k : s) !== null && _l !== void 0 ? _l : \"log\",\n        strictRequired: (_o = (_m = o.strictRequired) !== null && _m !== void 0 ? _m : s) !== null && _o !== void 0 ? _o : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_p = o.loopRequired) !== null && _p !== void 0 ? _p : MAX_EXPRESSION,\n        loopEnum: (_q = o.loopEnum) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        meta: (_r = o.meta) !== null && _r !== void 0 ? _r : true,\n        messages: (_s = o.messages) !== null && _s !== void 0 ? _s : true,\n        inlineRefs: (_t = o.inlineRefs) !== null && _t !== void 0 ? _t : true,\n        schemaId: (_u = o.schemaId) !== null && _u !== void 0 ? _u : \"$id\",\n        addUsedSchema: (_v = o.addUsedSchema) !== null && _v !== void 0 ? _v : true,\n        validateSchema: (_w = o.validateSchema) !== null && _w !== void 0 ? _w : true,\n        validateFormats: (_x = o.validateFormats) !== null && _x !== void 0 ? _x : true,\n        unicodeRegExp: (_y = o.unicodeRegExp) !== null && _y !== void 0 ? _y : true,\n        int32range: (_z = o.int32range) !== null && _z !== void 0 ? _z : true,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nexports.default = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n//# sourceMappingURL=core.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// https://github.com/ajv-validator/ajv/issues/889\nconst equal = require(\"fast-deep-equal\");\nequal.code = 'require(\"ajv/dist/runtime/equal\").default';\nexports.default = equal;\n//# sourceMappingURL=equal.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction ucs2length(str) {\n    const len = str.length;\n    let length = 0;\n    let pos = 0;\n    let value;\n    while (pos < len) {\n        length++;\n        value = str.charCodeAt(pos++);\n        if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n            // high surrogate, and there is a next character\n            value = str.charCodeAt(pos);\n            if ((value & 0xfc00) === 0xdc00)\n                pos++; // low surrogate\n        }\n    }\n    return length;\n}\nexports.default = ucs2length;\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default';\n//# sourceMappingURL=ucs2length.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ValidationError extends Error {\n    constructor(errors) {\n        super(\"validation failed\");\n        this.errors = errors;\n        this.ajv = this.validation = true;\n    }\n}\nexports.default = ValidationError;\n//# sourceMappingURL=validation_error.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateAdditionalItems = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n            (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n            return;\n        }\n        validateAdditionalItems(cxt, items);\n    },\n};\nfunction validateAdditionalItems(cxt, items) {\n    const { gen, schema, data, keyword, it } = cxt;\n    it.items = true;\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);\n    }\n    else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n    }\n    function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i) => {\n            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n            if (!it.allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n    }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports.default = def;\n//# sourceMappingURL=additionalItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must NOT have additional properties\",\n    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,\n};\nconst def = {\n    keyword: \"additionalProperties\",\n    type: [\"object\"],\n    schemaType: [\"boolean\", \"object\"],\n    allowUndefined: true,\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, errsCount, it } = cxt;\n        /* istanbul ignore if */\n        if (!errsCount)\n            throw new Error(\"ajv implementation error\");\n        const { allErrors, opts } = it;\n        it.props = true;\n        if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n        checkAdditionalProperties();\n        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n        function checkAdditionalProperties() {\n            gen.forIn(\"key\", data, (key) => {\n                if (!props.length && !patProps.length)\n                    additionalPropertyCode(key);\n                else\n                    gen.if(isAdditional(key), () => additionalPropertyCode(key));\n            });\n        }\n        function isAdditional(key) {\n            let definedProp;\n            if (props.length > 8) {\n                // TODO maybe an option instead of hard-coded 8?\n                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n            }\n            else if (props.length) {\n                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));\n            }\n            else {\n                definedProp = codegen_1.nil;\n            }\n            if (patProps.length) {\n                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n            }\n            return (0, codegen_1.not)(definedProp);\n        }\n        function deleteAdditional(key) {\n            gen.code((0, codegen_1._) `delete ${data}[${key}]`);\n        }\n        function additionalPropertyCode(key) {\n            if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n                deleteAdditional(key);\n                return;\n            }\n            if (schema === false) {\n                cxt.setParams({ additionalProperty: key });\n                cxt.error();\n                if (!allErrors)\n                    gen.break();\n                return;\n            }\n            if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n                const valid = gen.name(\"valid\");\n                if (opts.removeAdditional === \"failing\") {\n                    applyAdditionalSchema(key, valid, false);\n                    gen.if((0, codegen_1.not)(valid), () => {\n                        cxt.reset();\n                        deleteAdditional(key);\n                    });\n                }\n                else {\n                    applyAdditionalSchema(key, valid);\n                    if (!allErrors)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                }\n            }\n        }\n        function applyAdditionalSchema(key, valid, errors) {\n            const subschema = {\n                keyword: \"additionalProperties\",\n                dataProp: key,\n                dataPropType: util_1.Type.Str,\n            };\n            if (errors === false) {\n                Object.assign(subschema, {\n                    compositeRule: true,\n                    createErrors: false,\n                    allErrors: false,\n                });\n            }\n            cxt.subschema(subschema, valid);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=additionalProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i) => {\n            if ((0, util_1.alwaysValidSchema)(it, sch))\n                return;\n            const schCxt = cxt.subschema({ keyword: \"allOf\", schemaProp: i }, valid);\n            cxt.ok(valid);\n            cxt.mergeEvaluated(schCxt);\n        });\n    },\n};\nexports.default = def;\n//# sourceMappingURL=allOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"anyOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    code: code_1.validateUnion,\n    error: { message: \"must match a schema in anyOf\" },\n};\nexports.default = def;\n//# sourceMappingURL=anyOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { min, max } }) => max === undefined\n        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`\n        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,\n};\nconst def = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        }\n        else {\n            min = 1;\n        }\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === undefined && min === 0) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            let cond = (0, codegen_1._) `${len} >= ${min}`;\n            if (max !== undefined)\n                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === undefined && min === 1) {\n            validateItems(valid, () => gen.if(valid, () => gen.break()));\n        }\n        else if (min === 0) {\n            gen.let(valid, true);\n            if (max !== undefined)\n                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);\n        }\n        else {\n            gen.let(valid, false);\n            validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n            const schValid = gen.name(\"_valid\");\n            const count = gen.let(\"count\", 0);\n            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n            gen.forRange(\"i\", 0, len, (i) => {\n                cxt.subschema({\n                    keyword: \"contains\",\n                    dataProp: i,\n                    dataPropType: util_1.Type.Num,\n                    compositeRule: true,\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code((0, codegen_1._) `${count}++`);\n            if (max === undefined) {\n                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());\n            }\n            else {\n                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());\n                if (min === 1)\n                    gen.assign(valid, true);\n                else\n                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=contains.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nexports.error = {\n    message: ({ params: { property, depsCount, deps } }) => {\n        const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;\n    },\n    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n};\nconst def = {\n    keyword: \"dependencies\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: exports.error,\n    code(cxt) {\n        const [propDeps, schDeps] = splitDependencies(cxt);\n        validatePropertyDeps(cxt, propDeps);\n        validateSchemaDeps(cxt, schDeps);\n    },\n};\nfunction splitDependencies({ schema }) {\n    const propertyDeps = {};\n    const schemaDeps = {};\n    for (const key in schema) {\n        if (key === \"__proto__\")\n            continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n    }\n    return [propertyDeps, schemaDeps];\n}\nfunction validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n    const { gen, data, it } = cxt;\n    if (Object.keys(propertyDeps).length === 0)\n        return;\n    const missing = gen.let(\"missing\");\n    for (const prop in propertyDeps) {\n        const deps = propertyDeps[prop];\n        if (deps.length === 0)\n            continue;\n        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n            property: prop,\n            depsCount: deps.length,\n            deps: deps.join(\", \"),\n        });\n        if (it.allErrors) {\n            gen.if(hasProperty, () => {\n                for (const depProp of deps) {\n                    (0, code_1.checkReportMissingProp)(cxt, depProp);\n                }\n            });\n        }\n        else {\n            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n            (0, code_1.reportMissingProp)(cxt, missing);\n            gen.else();\n        }\n    }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nfunction validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    for (const prop in schemaDeps) {\n        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))\n            continue;\n        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n        }, () => gen.var(valid, true) // TODO var\n        );\n        cxt.ok(valid);\n    }\n}\nexports.validateSchemaDeps = validateSchemaDeps;\nexports.default = def;\n//# sourceMappingURL=dependencies.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params }) => (0, codegen_1.str) `must match \"${params.ifClause}\" schema`,\n    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,\n};\nconst def = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) {\n            (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n            return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let(\"ifClause\");\n            cxt.setParams({ ifClause });\n            gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        }\n        else if (hasThen) {\n            gen.if(schValid, validateClause(\"then\"));\n        }\n        else {\n            gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: \"if\",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false,\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return () => {\n                const schCxt = cxt.subschema({ keyword }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause)\n                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);\n                else\n                    cxt.setParams({ ifClause: keyword });\n            };\n        }\n    },\n};\nfunction hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports.default = def;\n//# sourceMappingURL=if.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst additionalItems_1 = require(\"./additionalItems\");\nconst prefixItems_1 = require(\"./prefixItems\");\nconst items_1 = require(\"./items\");\nconst items2020_1 = require(\"./items2020\");\nconst contains_1 = require(\"./contains\");\nconst dependencies_1 = require(\"./dependencies\");\nconst propertyNames_1 = require(\"./propertyNames\");\nconst additionalProperties_1 = require(\"./additionalProperties\");\nconst properties_1 = require(\"./properties\");\nconst patternProperties_1 = require(\"./patternProperties\");\nconst not_1 = require(\"./not\");\nconst anyOf_1 = require(\"./anyOf\");\nconst oneOf_1 = require(\"./oneOf\");\nconst allOf_1 = require(\"./allOf\");\nconst if_1 = require(\"./if\");\nconst thenElse_1 = require(\"./thenElse\");\nfunction getApplicator(draft2020 = false) {\n    const applicator = [\n        // any\n        not_1.default,\n        anyOf_1.default,\n        oneOf_1.default,\n        allOf_1.default,\n        if_1.default,\n        thenElse_1.default,\n        // object\n        propertyNames_1.default,\n        additionalProperties_1.default,\n        dependencies_1.default,\n        properties_1.default,\n        patternProperties_1.default,\n    ];\n    // array\n    if (draft2020)\n        applicator.push(prefixItems_1.default, items2020_1.default);\n    else\n        applicator.push(additionalItems_1.default, items_1.default);\n    applicator.push(contains_1.default);\n    return applicator;\n}\nexports.default = getApplicator;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateTuple = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports.default = def;\n//# sourceMappingURL=items.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst additionalItems_1 = require(\"./additionalItems\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { schema, parentSchema, it } = cxt;\n        const { prefixItems } = parentSchema;\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        if (prefixItems)\n            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);\n        else\n            cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nexports.default = def;\n//# sourceMappingURL=items2020.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"not\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            cxt.fail();\n            return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n            keyword: \"not\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false,\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n    },\n    error: { message: \"must NOT be valid\" },\n};\nexports.default = def;\n//# sourceMappingURL=not.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must match exactly one schema in oneOf\",\n    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,\n};\nconst def = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n            return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i) => {\n                let schCxt;\n                if ((0, util_1.alwaysValidSchema)(it, sch)) {\n                    gen.var(schValid, true);\n                }\n                else {\n                    schCxt = cxt.subschema({\n                        keyword: \"oneOf\",\n                        schemaProp: i,\n                        compositeRule: true,\n                    }, schValid);\n                }\n                if (i > 0) {\n                    gen\n                        .if((0, codegen_1._) `${schValid} && ${valid}`)\n                        .assign(valid, false)\n                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)\n                        .else();\n                }\n                gen.if(schValid, () => {\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt)\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=oneOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=patternProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst items_1 = require(\"./items\");\nconst def = {\n    keyword: \"prefixItems\",\n    type: \"array\",\n    schemaType: [\"array\"],\n    before: \"uniqueItems\",\n    code: (cxt) => (0, items_1.validateTuple)(cxt, \"items\"),\n};\nexports.default = def;\n//# sourceMappingURL=prefixItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validate_1 = require(\"../../compile/validate\");\nconst code_1 = require(\"../code\");\nconst util_1 = require(\"../../compile/util\");\nconst additionalProperties_1 = require(\"./additionalProperties\");\nconst def = {\n    keyword: \"properties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n        }\n        const allProps = (0, code_1.allSchemaProperties)(schema);\n        for (const prop of allProps) {\n            it.definedProperties.add(prop);\n        }\n        if (it.opts.unevaluated && allProps.length && it.props !== true) {\n            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n        }\n        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (properties.length === 0)\n            return;\n        const valid = gen.name(\"valid\");\n        for (const prop of properties) {\n            if (hasDefault(prop)) {\n                applyPropertySchema(prop);\n            }\n            else {\n                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n                applyPropertySchema(prop);\n                if (!it.allErrors)\n                    gen.else().var(valid, true);\n                gen.endIf();\n            }\n            cxt.it.definedProperties.add(prop);\n            cxt.ok(valid);\n        }\n        function hasDefault(prop) {\n            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n        }\n        function applyPropertySchema(prop) {\n            cxt.subschema({\n                keyword: \"properties\",\n                schemaProp: prop,\n                dataProp: prop,\n            }, valid);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=properties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"property name must be valid\",\n    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,\n};\nconst def = {\n    keyword: \"propertyNames\",\n    type: \"object\",\n    schemaType: [\"object\", \"boolean\"],\n    error,\n    code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const valid = gen.name(\"valid\");\n        gen.forIn(\"key\", data, (key) => {\n            cxt.setParams({ propertyName: key });\n            cxt.subschema({\n                keyword: \"propertyNames\",\n                data: key,\n                dataTypes: [\"string\"],\n                propertyName: key,\n                compositeRule: true,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), () => {\n                cxt.error(true);\n                if (!it.allErrors)\n                    gen.break();\n            });\n        });\n        cxt.ok(valid);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=propertyNames.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: [\"then\", \"else\"],\n    schemaType: [\"object\", \"boolean\"],\n    code({ keyword, parentSchema, it }) {\n        if (parentSchema.if === undefined)\n            (0, util_1.checkStrictMode)(it, `\"${keyword}\" without \"if\" is ignored`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=thenElse.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst def = {\n    keyword: \"id\",\n    code() {\n        throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID');\n    },\n};\nexports.default = def;\n//# sourceMappingURL=id.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst id_1 = require(\"./id\");\nconst ref_1 = require(\"./ref\");\nconst core = [\n    \"$schema\",\n    \"$id\",\n    \"$defs\",\n    \"$vocabulary\",\n    { keyword: \"$comment\" },\n    \"definitions\",\n    id_1.default,\n    ref_1.default,\n];\nexports.default = core;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports.default = def;\n//# sourceMappingURL=ref.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst types_1 = require(\"../discriminator/types\");\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag \"${tagName}\" must be string`\n        : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n            throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n            throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n            throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                const sch = oneOf[i];\n                const propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") {\n                    throw new Error(`discriminator: oneOf schemas must have \"properties/${tagName}\"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiscrError = void 0;\nvar DiscrError;\n(function (DiscrError) {\n    DiscrError[\"Tag\"] = \"tag\";\n    DiscrError[\"Mapping\"] = \"mapping\";\n})(DiscrError = exports.DiscrError || (exports.DiscrError = {}));\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"./core\");\nconst validation_1 = require(\"./validation\");\nconst applicator_1 = require(\"./applicator\");\nconst format_1 = require(\"./format\");\nconst metadata_1 = require(\"./metadata\");\nconst draft7Vocabularies = [\n    core_1.default,\n    validation_1.default,\n    (0, applicator_1.default)(),\n    format_1.default,\n    metadata_1.metadataVocabulary,\n    metadata_1.contentVocabulary,\n];\nexports.default = draft7Vocabularies;\n//# sourceMappingURL=draft7.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match format \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self } = it;\n        if (!opts.validateFormats)\n            return;\n        if ($data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fDef = gen.const(\"fDef\", (0, codegen_1._) `${fmts}[${schemaCode}]`);\n            const fType = gen.let(\"fType\");\n            const format = gen.let(\"format\");\n            // TODO simplify\n            gen.if((0, codegen_1._) `typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || \"string\"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `\"string\"`).assign(format, fDef));\n            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false)\n                    return codegen_1.nil;\n                return (0, codegen_1._) `${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async\n                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n                    : (0, codegen_1._) `${format}(${data})`;\n                const validData = (0, codegen_1._) `(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true)\n                return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType)\n                cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp\n                    ? (0, codegen_1.regexpCode)(fmtDef)\n                    : opts.code.formats\n                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`\n                        : undefined;\n                const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n                if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n                    return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];\n                }\n                return [\"string\", fmtDef, fmt];\n            }\n            function validCondition() {\n                if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async)\n                        throw new Error(\"async format in sync schema\");\n                    return (0, codegen_1._) `await ${fmtRef}(${data})`;\n                }\n                return typeof format == \"function\" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=format.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst format_1 = require(\"./format\");\nconst format = [format_1.default];\nexports.default = format;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.contentVocabulary = exports.metadataVocabulary = void 0;\nexports.metadataVocabulary = [\n    \"title\",\n    \"description\",\n    \"default\",\n    \"deprecated\",\n    \"readOnly\",\n    \"writeOnly\",\n    \"examples\",\n];\nexports.contentVocabulary = [\n    \"contentMediaType\",\n    \"contentEncoding\",\n    \"contentSchema\",\n];\n//# sourceMappingURL=metadata.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to constant\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"const\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schemaCode, schema } = cxt;\n        if ($data || (schema && typeof schema == \"object\")) {\n            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);\n        }\n        else {\n            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=const.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        const eql = (0, util_1.useFunc)(gen, equal_1.default);\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._) `${eql}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? (0, codegen_1._) `${eql}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=enum.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst limitNumber_1 = require(\"./limitNumber\");\nconst multipleOf_1 = require(\"./multipleOf\");\nconst limitLength_1 = require(\"./limitLength\");\nconst pattern_1 = require(\"./pattern\");\nconst limitProperties_1 = require(\"./limitProperties\");\nconst required_1 = require(\"./required\");\nconst limitItems_1 = require(\"./limitItems\");\nconst uniqueItems_1 = require(\"./uniqueItems\");\nconst const_1 = require(\"./const\");\nconst enum_1 = require(\"./enum\");\nconst validation = [\n    // number\n    limitNumber_1.default,\n    multipleOf_1.default,\n    // string\n    limitLength_1.default,\n    pattern_1.default,\n    // object\n    limitProperties_1.default,\n    required_1.default,\n    // array\n    limitItems_1.default,\n    uniqueItems_1.default,\n    // any\n    { keyword: \"type\", schemaType: [\"string\", \"array\"] },\n    { keyword: \"nullable\", schemaType: \"boolean\" },\n    const_1.default,\n    enum_1.default,\n];\nexports.default = validation;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxItems\", \"minItems\"],\n    type: \"array\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxItems\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst ucs2length_1 = require(\"../../runtime/ucs2length\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxLength\", \"minLength\"],\n    type: \"string\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode, it } = cxt;\n        const op = keyword === \"maxLength\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;\n        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitLength.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    maximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    minimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    exclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    exclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: Object.keys(KWDs),\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitNumber.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxProperties\", \"minProperties\"],\n    type: \"object\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxProperties\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"multipleOf\",\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, it } = cxt;\n        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n        const prec = it.opts.multipleOfPrecision;\n        const res = gen.let(\"res\");\n        const invalid = prec\n            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n            : (0, codegen_1._) `${res} !== parseInt(${res})`;\n        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=multipleOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"pattern\",\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { data, $data, schema, schemaCode, it } = cxt;\n        // TODO regexp should be wrapped in try/catchs\n        const u = it.opts.unicodeRegExp ? \"u\" : \"\";\n        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);\n        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=pattern.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,\n    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,\n};\nconst def = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n            return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n            allErrorsMode();\n        else\n            exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties } = cxt.it;\n            for (const requiredKey of schema) {\n                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                    const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n                }\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) {\n                cxt.block$data(codegen_1.nil, loopAllRequired);\n            }\n            else {\n                for (const prop of schema) {\n                    (0, code_1.checkReportMissingProp)(cxt, prop);\n                }\n            }\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let(\"missing\");\n            if (useLoop || $data) {\n                const valid = gen.let(\"valid\", true);\n                cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            }\n            else {\n                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n                (0, code_1.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf(\"prop\", schemaCode, (prop) => {\n                cxt.setParams({ missingProperty: prop });\n                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({ missingProperty: missing });\n            gen.forOf(missing, schemaCode, () => {\n                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, codegen_1.not)(valid), () => {\n                    cxt.error();\n                    gen.break();\n                });\n            }, codegen_1.nil);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=required.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dataType_1 = require(\"../../compile/validate/dataType\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,\n};\nconst def = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n            return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let(\"i\", (0, codegen_1._) `${data}.length`);\n            const j = gen.let(\"j\");\n            cxt.setParams({ i, j });\n            gen.assign(valid, true);\n            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n            const item = gen.name(\"item\");\n            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n            const indices = gen.const(\"indices\", (0, codegen_1._) `{}`);\n            gen.for((0, codegen_1._) `;${i}--;`, () => {\n                gen.let(item, (0, codegen_1._) `${data}[${i}]`);\n                gen.if(wrongType, (0, codegen_1._) `continue`);\n                if (itemTypes.length > 1)\n                    gen.if((0, codegen_1._) `typeof ${item} == \"string\"`, (0, codegen_1._) `${item} += \"_\"`);\n                gen\n                    .if((0, codegen_1._) `typeof ${indices}[${item}] == \"number\"`, () => {\n                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                })\n                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = (0, util_1.useFunc)(gen, equal_1.default);\n            const outer = gen.name(\"outer\");\n            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {\n                cxt.error();\n                gen.assign(valid, false).break(outer);\n            })));\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=uniqueItems.js.map"],"names":["Object","defineProperty","exports","value","resolveSchema","getCompilingSchema","resolveRef","compileSchema","SchemaEnv","codegen_1","validation_error_1","names_1","resolve_1","util_1","validate_1","URI","constructor","env","_a","schema","this","refs","dynamicAnchors","schemaId","root","baseId","normalizeId","schemaPath","localRefs","meta","$async","sch","_sch","call","rootId","getFullPath","es5","lines","opts","code","ownProperties","gen","CodeGen","scope","_ValidationError","scopeValue","ref","default","_","validateName","scopeName","schemaCxt","allErrors","data","parentData","parentDataProperty","dataNames","dataPathArr","nil","dataLevel","dataTypes","definedProperties","Set","topSchemaRef","source","stringify","ValidationError","schemaEnv","errSchemaPath","jtd","errorPath","self","sourceCode","_compilations","add","validateFunctionCode","optimize","validateCode","toString","scopeRefs","process","validate","Function","makeValidate","get","errors","scopeValues","_values","unevaluated","props","items","evaluated","Name","undefined","dynamicProps","dynamicItems","e","logger","error","delete","inlineOrCompile","inlineRef","inlineRefs","schEnv","s2","s1","resolve","schemas","p","parse","refPath","_getFullPath","keys","length","getJsonPointer","id","schOrRef","schId","resolveUrl","schOrFunc","PREVENT_SCOPE_CHANGE","parsedRef","fragment","part","slice","split","partSchema","unescapeFragment","has","$ref","schemaHasRulesButRef","RULES","MissingRefError","Error","msg","super","missingRef","missingSchema","str","KeywordCxt","enumerable","ref_error_1","rules_1","compile_1","codegen_2","dataType_1","$dataRefSchema","defaultRegExp","flags","RegExp","META_IGNORE_OPTIONS","EXT_SCOPE_NAMES","removedOptions","errorDataPath","format","nullable","jsonPointers","extendRefs","missingRefs","processCode","strictDefaults","strictKeywords","uniqueItems","unknownFormats","cache","serialize","ajvErrors","deprecatedOptions","ignoreKeywordsWithRef","jsPropertySyntax","unicode","requiredOptions","o","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_s","_t","_u","_v","_w","_x","_y","_z","s","strict","_optz","regExp","strictSchema","strictNumbers","strictTypes","strictTuples","strictRequired","loopRequired","loopEnum","messages","addUsedSchema","validateSchema","validateFormats","unicodeRegExp","int32range","Ajv","formats","_loading","_cache","Map","ValueScope","prefixes","noLogs","console","log","warn","getLogger","formatOpt","getRules","checkOptions","_metaOpts","getMetaSchemaOptions","addInitialFormats","_addVocabularies","_addDefaultMetaSchema","keywords","addInitialKeywords","addMetaSchema","addInitialSchemas","addKeyword","$data","_dataRefSchema","$id","defaultMeta","schemaKeyRef","v","getSchema","compile","valid","_meta","_addSchema","_compileSchemaEnv","compileAsync","loadSchema","runCompileAsync","async","_schema","loadMetaSchema","$schema","_compileAsync","checkLoaded","loadMissingSchema","_loadSchema","addSchema","key","_validateSchema","Array","isArray","_checkUnique","throwOrLogError","message","errorsText","keyRef","getSchEnv","removeSchema","_removeAllSchemas","clear","cacheKey","addVocabulary","definitions","def","kwdOrDef","keyword","checkKeyword","eachItem","kwd","addRule","keywordMetaschema","definition","type","getJSONTypes","schemaType","k","forEach","t","getKeyword","rule","all","removeKeyword","group","rules","i","findIndex","splice","addFormat","name","separator","dataVar","map","instancePath","reduce","text","$dataMetaSchema","metaSchema","keywordsJsonPointers","JSON","jsonPointer","segments","seg","schemaOrData","regex","test","getSchemaRefs","set","startsWith","_compileMetaSchema","currentOpts","checkOpts","options","opt","optsSchemas","defs","metaOpts","KEYWORD_NAME","dataType","post","ruleGroup","find","push","before","addBeforeRule","implements","_rule","$dataRef","anyOf","equal","ucs2length","len","pos","charCodeAt","ajv","validation","validateAdditionalItems","params","cxt","parentSchema","it","checkStrictMode","const","setParams","pass","alwaysValidSchema","var","if","not","forRange","subschema","dataProp","dataPropType","Type","Num","break","validateItems","ok","code_1","allowUndefined","trackErrors","additionalProperty","errsCount","removeAdditional","allSchemaProperties","properties","patProps","patternProperties","deleteAdditional","additionalPropertyCode","applyAdditionalSchema","reset","Str","assign","compositeRule","createErrors","forIn","definedProp","propsSchema","schemaRefOrVal","isOwnProperty","or","usePattern","isAdditional","schCxt","schemaProp","mergeEvaluated","validateUnion","min","max","minContains","maxContains","next","fail","cond","validateItemsWithCount","schValid","count","let","checkLimits","_valid","block","result","validateSchemaDeps","validatePropertyDeps","property","depsCount","deps","property_ies","missingProperty","propDeps","schDeps","propertyDeps","schemaDeps","splitDependencies","missing","prop","hasProperty","propertyInData","join","depProp","checkReportMissingProp","checkMissingProp","reportMissingProp","else","mergeValidEvaluated","ifClause","then","hasThen","hasSchema","hasElse","validateIf","validateClause","additionalItems_1","prefixItems_1","items_1","items2020_1","contains_1","dependencies_1","propertyNames_1","additionalProperties_1","properties_1","patternProperties_1","not_1","anyOf_1","oneOf_1","allOf_1","if_1","thenElse_1","draft2020","applicator","validateTuple","validateArray","extraItems","schArr","l","fullTuple","minItems","maxItems","checkStrictTuple","prefixItems","failResult","passing","discriminator","util_2","patterns","alwaysValidPatterns","filter","checkProperties","allowMatchingProperties","evaluatedPropsToName","checkMatchingProperties","pat","validateProperties","alwaysValid","includes","validatePatternProperties","additionalProperties","allProps","toHash","hasDefault","applyPropertySchema","endIf","useDefaults","propertyName","id_1","ref_1","core","callRef","getValidate","rootName","callRootRef","schOrEnv","callValidate","schName","inlineRefSchema","passCxt","passContext","addErrorsFrom","errs","vErrors","addEvaluatedFrom","schEvaluated","try","callValidateCode","throw","callAsyncRef","types_1","discrError","tagName","DiscrError","Tag","tag","oneOf","mapping","getProperty","applyTagSchema","oneOfMapping","topRequired","hasRequired","tagRequired","propSch","addMappings","required","addMapping","enum","tagValue","getMapping","elseIf","Mapping","validateMapping","core_1","validation_1","applicator_1","format_1","metadata_1","draft7Vocabularies","metadataVocabulary","contentVocabulary","schemaCode","ruleType","fmts","fDef","fType","fail$data","callFormat","validData","invalidFmt","validate$DataFormat","formatDef","unknownMsg","unknownFormat","fmtType","fmtRef","fmtDef","regexpCode","fmt","getFormat","validCondition","validateFormat","equal_1","useFunc","useLoop","eql","block$data","forOf","vSchema","equalCode","limitNumber_1","multipleOf_1","limitLength_1","pattern_1","limitProperties_1","required_1","limitItems_1","uniqueItems_1","const_1","enum_1","comp","op","operators","GT","LT","ucs2length_1","ops","KWDs","maximum","okStr","LTE","minimum","GTE","exclusiveMaximum","exclusiveMinimum","prec","multipleOfPrecision","res","invalid","u","loopAllRequired","allErrorsMode","loopUntilMissing","exitOnErrorMode","requiredKey","noPropertyInData","j","itemTypes","getSchemaTypes","loopN","item","wrongType","checkDataTypes","DataType","Wrong","indices","for","loopN2","outer","label","some"],"sourceRoot":""}